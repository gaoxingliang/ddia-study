# 第一章 可靠, 可扩展与可维护的应用

常见的APP(数据系统)包括如下模块:

- 数据库
- 高速缓存
- 索引
- 流式处理 -- 持续发送消息到另外一个模块
- 批处理 -- 定期处理大量的累计数据

## 认识数据系统

为系统异常而设计 -- 局部失效? 负载增加? 降级? 

### 可靠性

- 硬件故障 (比如硬盘故障)
- 软件错误
- 人为错误 (操作失误, 运维)

### 可扩展性

#### 描述负载

##### 描述了推特的tweet流的设计.

它的设计也是渐进型的:

形态1: 用关系数据库维护的tweets:

![image-20200211211623785](./image-20200211211623785.png)

形态2:加缓存 

![image-20200211211902008](./image-20200211211902008.png)

形态3:

![image-20200211212216616](./image-20200211212216616.png)

#### 描述性能

延迟和吞吐量



### 可维护性



# 第二章  数据模型与查询语言

  大多数都是调用下一层接口来实现高级功能的

## 文档数据库和关系数据库

文档数据库相比而言, 有更强的局部性和无模式. 而sql则在连接操作上更牛 且具有更简洁的表达.

# 第三章 数据存储与检索

常见的存储引擎:

| 存储引擎           |      |      |      |
| ------------------ | ---- | ---- | ---- |
| 日志结构型存储引擎 |      |      |      |
| 面向页的存储引擎   |      |      |      |
| 列存储        |      |      |      |


## 渐进的实现一个K-V单机存储

#### (1) 一个最简单的k-v存储 (不断向文件追加字符)



![image-20200211213931505](image-20200211213931505.png)

优点:  写入快.   

缺点:  如果数据多了, 那么查询慢O(n)

#### (2) 解决查询问题, 引入索引.  那么相对的 写入肯定会变慢 (因为还要更新索引了)

使用Hash索引放在内存中. key是上面的k. value是最新的v对应在文件中的offset.

问题: (1)文件太大. (2)key放不到一个完整的内存中怎么办? (3) 区间查询

解决: (1) 分段存储(过一段时间后生成一个新的文件) + 加入压缩. 后台去掉重复k (2) 待定 (3) 待定

其他思考点: 

- 采用高效的二进制格式 而不是CSV
- 删除记录通过墓碑标记实现 一个特殊的标记
- 崩溃恢复 -- 从头遍历每个段来从建hashmap
- 部分写入 -- 校验和 丢弃破坏记录
- 并发控制 
- 采用追加的方式而不是原地修改文件 --- 顺序写更快, 并发和崩溃恢复更容易

#### (3) 为了解决内存放不下和区间查询而引入的sstables/LSM-Tree









